Чем горутины отличаются от потоков ОС?

Горутина — это лёгкий поток Go, который занимает поток ОС только во время выполнения. При блокировке или завершении она освобождает поток. Поэтому Go может эффективно обрабатывать тысячи горутин одновременно, без большого расхода памяти.

Когда стоит использовать sync.Mutex, а когда — каналы?

Когда горутины общаются — используем канал.
Когда горутины делят общую область данных — используем мьютекс.


Что такое work stealing в планировщике Go?

Каждый P (планировщик) — это слот исполнения. Он хранит очередь goroutine. Поток (M) может исполнять задачи только если прикреплён к P.
Если у P очередь пуста — он временно простаивает. Тогда он пытается украсть goroutine из конца очереди другого P. Это и называется work stealing.

Как планировщик Go обрабатывает блокирующие операции? 

Когда goroutine выполняет блокирующую операцию, она снимается с исполнения и ставится в очередь ожидания (например, у канала, мьютекса или poller’а).
Когда условие разблокировки выполнено — она просто добавляется обратно в очередь планировщика и исполняется, когда дойдёт очередь.

Какие алгоритмы лежат в основе сборщика мусора в Go?

В Go память собирается по достижимости: если до объекта нельзя дойти по ссылкам из стека или глобальных переменных, он считается мусором. Сборщик в фоне отмечает живые объекты, чистит мёртвые, а специальный механизм следит за тем, чтобы не потерять новые ссылки во время этого процесса.

Чтобы избежать утечек памяти в Go, важно правильно управлять жизненным циклом горутин с помощью контекстов или каналов, всегда закрывать каналы, не оставлять горутины висящими на блокирующих операциях, контролировать буферизацию каналов и избегать бессмысленного создания горутин без завершения.

Зачем в Go используются пустые структуры?

весят 0 байт. когда нужно просто зафикисровать факт, что что-то есть или передано

Чем интерфейсы в Go отличаются от интерфейсов в других языках?

В Go тип удовлетворяет интерфейсу автоматически, если реализует все методы.
В других языках нужно явно указать implements / interface.

В Go структура может реализовывать интерфейс без явного намерения.

Как нарушение Single Responsibility усложняет поддержку?

Если класс делает всё подряд — легко что-то ломается.
Границы ответственности размыты.
Дополнительная логика подключается через инъекцию, а не встраивается.
Так структура остаётся чистой, изменения — безопасными.

В чем основное отличие Kafka от RabbitMQ?

Kafka — это журнал, где данные хранятся и могут быть перечитаны,
а RabbitMQ — брокер, который маршрутизирует и доставляет сообщения, удаляя их после обработки.

Как гарантировать доставку сообщений в системе с Message Queue?

Чтобы гарантировать доставку в Message Queue-системах, нужны:

Персистентность сообщений (диск)

Подтверждение доставки (ack)

Повторная доставка при сбоях 

Идемпотентность обработки

В Kafka, например, это реализуется так:
Продюсер получает подтверждение от брокера — сообщение записано.
Консюмер сам запрашивает сообщения из журнала, где они уже есть.
Повторные чтения возможны, ответственность за корректную обработку на консюмере.

Какие преимущества у PostgreSQL перед MySQL?

С MySQL почти не работал, но знаю, что там куча компромиссов.
Например, нет нормальных транзакций, типы проверяются нестрого — можно вставить строку в int и оно «прокатит».
В PostgreSQL всё строго: транзакции настоящие, ошибки не игнорятся, JSON — полноценный, можно даже по нему индексировать.
Короче, если на прод — я беру PostgreSQL, потому что он не прощает глупости и даёт контроль.

WHERE фильтрует строки до агрегации.
HAVING фильтрует после GROUP BY, на уровне агрегатных значений.

https://www.xvv1deos.com/video.hmcdthh8d93/nblflmsnswtfhd


https://tol.intimcity.guru/indi/anketa764784.htm
